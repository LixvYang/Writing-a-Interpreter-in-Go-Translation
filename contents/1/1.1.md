# 1.1词法分析

为了我们使用源代码，我们需要将其转换为更易于访问的形式。就像我们在编辑器中使用纯文本一样简单，当试图用一种编程语言将它转换成另一种编程语言时，它会变得很麻烦。因此我们需要做的是用其他更容易使用的形式表示我们的源代码。在评估之前，我们将更改源代码的表示两次： 

source code -> Tokens -> Abstract Syntax Tree

第一次转换，从源代码到Tokens称为词法分析。它又词法分析器(分词器/扫描器-有些使用一个词或另一个词来表示行为上的细微差别，我们在本书中可以忽略)完成。Tokens本身是小的、易于分类的数据结构，然后被提供给解析器，它进行第二次转换并将标记编程“抽象语法树”。

下面一个例子。这是给词法分析器的输入：
```
"let x = 5 + 5;"
```

并且从词法分析器中得到的结果看起来有点像这样：
```
[
    LET,
    IDENTIFIER("x"),
    EQUAL_SIGN,INTEGER(5),
    PLUS_SIGN,INTEGER(5),
    SEMICOLON
]
```

全部的Tokens都有对应的源代码表示。在LET的情况下为"let"，在PLUS_SIGN的情况下为"+"，以此类推。例如像我们示例中IDENTIFIER 和 INTEGER还附加了它们所代表的具体值：5(不是"5"!)在INTEGER的情况下和IDENTTIFIER的情况下是"x"。但是究竟什么构成“Tokens”在不同的词法分析器实现之间有所不同。例如，一些词法分析器仅在解析阶段或者稍后将"5"转换成整数，而不是在构造标记时。

关于这个例子有一点需要注意：空白字符不会显示为Tokens。在我们的例子中没问题，因为空白长度在Monkey语言中并不重要。空格只是作为其他Tokens的分隔符。无所谓是否我们输入以下内容：
```
let x = 5;
```
或者
```
let x    =    5;
```
换句话说，像Python，空白的长度很重要。那意味着词法分析器不能只**吃掉**空格和换行符。它必须将空白字符作为标记输出，以便解析器稍后可以理解它们（或者输出错误，当然，如果不够或者太多）。

一个生产就绪的词法分析器还可以将行号、列号和文件名附加到Tokens。为什么？例如，为了稍后再解析阶段输出更多有用的错误信息。它可以输出而不是"error: expected semicolon token":
```
"error: expected semicolon token. line 42, column 23, "
```
我们将不会为此烦恼，不是因为它太复杂，而是因为它会脱离Token和词法分析器的基本简单性，使其更难以理解。

****
