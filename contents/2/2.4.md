# 解析器起步：解析LET语句
在Monkey中，变量绑定语句是如下的形式：
```
let x = 5;
let y = 10;
let foobar = add(5,5);
let barfoo = 5 * 5 / 10 + 18 - add(5,5) + multiply(124);
let anotherName = barfoo;
```
这些语句被称为“let 语句”，并且给定一个名字绑定一个值。`let x = 5;`绑定了5给x。在这个章节中我们的工作是正确解析let语句。

所以现在，我们将跳过解析产生给定变量绑定值的表达式，稍后再回来——只要我们知道如何让它们自己解析表达式。

正确解析let语句是什么意思？这意味着解析器生成一个AST来准确地表示原始let语句中包含的信息。这听起来很合理，但我们还没有AST，也不知道它应该是什么样子。所以我们的第一个任务是仔细查看Monkey源代码，看看它是如何构建的，这样我们就可以定义AST中能够准确表示let语句的必要部分。这是一个完全有效的用Monkey编写的程序：
```
let x = 10;
let y = 15;

let add = fn(a,b) {
    return a + b;
};
```
Monkey中的代码是一系列语句。在这个例子中哦我们能看见三个语句，三个变量绑定-let语句-如下形式：
```
let <identifier> = <expression>;
```
Monkey中的let语句由两个变化组成：标识符和表达式。在上面的例子中，x，y和add是标识符。10，15和函数文字是表达式。

在我们继续之前，有必要就语句和表达式之间的不同说几句。表达式会产生值，语句不会。让x=5不会产生值，而5会(它产生的值为5)。return5；语句不会产生值，但add(5,5)会。这种区别——表达式产生之，语句不会——根据你问的人而变化，但它足以满足我们的需求。

一句话精确到为一个表达式或一个语句，它产生就分为无值和有值，取决于编程语言。在某些语言中，函数字面量(例如：fn(x,y){return x + y;})是表达式，可以允许任何其他表达式的任何地方使用。在其他编程语言中，尽管函数文字只能是程序顶层的函数声明语句的一部分。一些语言也有“if 表达式”，其中条件是表达式并产生一个值。 这完全取决于语言设计者所做的选择。 正如你将看到的，Monkey 中的很多东西都是表达式，包括函数字面量。

回到我们的AST，看一下下面的例子，我们可以看到它需要两个不同的根类型：表达式(expressions)和语句(statements)。开始看我们的AST：
```go
// ast.ast.go

package ast

type Node interface {
    TokenLiteral() string
}

type Statement interface {
    Node
    statementNode()
}

type Expression interface {
    Node
    expressionNode()
}
```
在这里我们有三个接口叫Node,Statement和Expression。我们每个AST的节点必须实现Node接口，意味着它必须提供一个TokenLiteral()方法来返回与其关联的token的字面值。TOkenLiteral()将仅用于调试和测试。我们将要构建的AST仅由相互连接的节点组成——比较它是一棵树。其中一些节点实现了Statement和一些Expression接口。这些接口分别称为statementNode和expressionNode的虚拟方法。它们不是绝对必要的，但通过指导Go编译器并可能导致它在我们使用语句时抛出错误来帮助我们，反之亦然。

这是我们实现的第一个Node：
```go
// ast/ast.go

type Program struct {
    Statements []statement
}

func (p *program) TokenLiteral() string {
    if len(p.Statements) > 0 {
        return p.Statements[0].TokenLiteral()
    } else {
        return ""
    }
}
```
Program 节点






