# 2.6解析表达式
个人看法，我认为解析表达式是我写解析器最有意思的部分。作为我们仅仅看到的，解析语句是相当直观。我们通过“左到右”tokens，期望或拒绝下一个token，如果一切合适我们将返回一个AST节点。

解析表达式，在另一方面，包含了更多挑战。运算符优先级可能是第一个想到的，最好用一个例子来说明。让我们说我们要解析以下算数表达式：
```go
5 * 5 + 10
```
我们在这里想要一个表达式像这样的AST:
```go
((5 * 5) + 10)
```
也就是说，5 * 5在AST里需要变得更深并且在添加之前进行评估。为了生产一个看起来像这样的AST，解析器已经知道操作运算符*比+更高有优先级。这是对操作运算符最常见的例子了，但是也有许多种同样重要的实例。考虑一下这个表达式：
```go
5 * (5 + 10)
```
这里的括号将5和10组合在一起，并给它们一个“优先级”,现在必须在乘法之前评估加法。那是因为括号具有比*更高的优先级。我们很快就会看到，还有一些案例优先级起着至关重要的作用。

另一个大的挑战是在表达式里有相同种类的tokens能发生在许多位置。和这个相反，let token仅仅只能发生在let语句的开头，这使得很容易确定语句的其余部分应该是什么。现在看这个表达式：
```go
-5 - 10
```
这里的-操作符发生在表达式的开头，作为一个前缀操作符，并且然后作为中间的中缀运算符。此处出现了相同挑战的变体：
```go
5 * (add(2,3) + 10)
```
即使你可能不认识括弧作为运算符，它们给我们带来了和以前例子里相同的问题。本例中的一组外括号比表示分组表达式。内部对表示“调用表达式”。token位置的有效性现在取决于上下文、前后的token以及它们的优先级。

## Monkey种的表达式
在 Monkey 编程语言中，除了let和return语句之外，所有的东西都是一个表达式。 这些表达方式多种多样。

Monkey设计前缀运算符的表达式：
```go
-5
!true
!false
```
并且当然它还有中缀运算符(或中间运算符)
```go
5 + 5
5 - 5
5 / 5
5 * 5
```
除了这些基本的算术运算符外，还有下面的比较运算符:
```go
foo == bar
foo != bar
foo < bar
foo > bar
```
并且当然，作为我们之前看到的，我们能使用括号给表达式分组并影响评估顺序：
```go
5 * (5 + 5)
((5 + 5) * 5) * 5
```
然后是调用表达式：
```go
add(2, 3)
add(add(2, 3), add(5, 10))
max(5, add(5, (5 * 5)))
```
也有标识符表达式:
```go
foo * bar / foobar
add(foo, bar)
```
在Monkey中的函数是第一类公民，使得，函数字面量也是表达式。我们能使用let语句去绑定给函数一个名字。函数字面量仅仅只是语句中的表达式：
```
let add = fn(x, y) { return x + y };
```
并且在这里我们使用一个函数字面量代替标识符:
```
fn(x, y) { return x + y }(5, 5)
(fn(x) { return x }(5) + 10 ) * 10
```
与许多广泛使用的编程语言相比，我们在Monkey中也有“if 表达式”：
```
let result = if (10 > 5) { true } else { false };
result // => true
```
看着所有这些不同形式的表达式，很明显我们需要一种非常好的方法来正确解析它们，并以可理解和可扩展的方式进行解析。我们根据当前token做什么的就方法不会让我们走得很远-至少不是不想撤掉我们的头发。这就是Vaughan Partt的用武之地。

## 自顶而下的运算符优先级（或：Pratt Parsing）
在他的论文上“自顶而下的运算符优先级”Vaughan Pratt提出一种解析表达式，用他的话说：
> […] is very simple to understand, trivial to implement, easy to use, extremely efficient in practice if not in theory, yet flexible enough to meet most reasonable syntactic needs of users […]

> […] 非常容易理解，易于实现，易于使用，效率极高,在实践中，如果不是理论上，但足够灵活以满足用户最合理的语法需求 […]

论文发表于1973年，但是在此后的许多年里，Partt提出的想法没有大量的追随者。直到最近几年，其他程序员才重新发现了Partt的论文，写了他并使Partt的解析方法越来越受欢迎。Douglas Crockford 的（“JavaScript: The Good Parts”成名）文章称为([自定而下运算符优先级](http://crockford.com/javascript/)，展示了如何将 Pratt 的想法转化为 JavaScript（Crockford 在构建 JSLint 时所做的）。 然后是优秀的“游戏编程模式”一书的作者 Bob Nystrom [强烈推荐的文章](http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/)，它通过提供简洁的 Java 示例代码使 Pratt 的方法非常易于理解和遵循。

三者描述的解析方式称为自顶而下运算符优先级解析或Partt解析是作为基于上下无关文法和Backus-Naur-Form的解析器的替代方案而发明的。

这也是主要区别：而不是关联解析函数(想想我们的parseLetStatement方法)与语法规则(在BNF或)